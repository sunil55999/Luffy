Context:  
We have a multi-token Telegram message copying system using Telethon, multiple message worker queues, and per-pair filter configuration in a JSON column (`filters`).  

We need to:
1. Implement per-pair text watermarking on images/media.  
2. Ensure the watermark has fixed dimensions, opacity, and center placement like "@Traders_Hive" in the sample chart.  
3. Avoid breaking message forwarding or increasing error rates.  

Steps to Implement:

1. **Database & Config**:
   - Extend `filters` JSON for each pair:
     ```
     {
       "watermark_enabled": true,
       "watermark_text": "@Traders_Hive"
     }
     ```
   - Add helper in `database.py`:
     ```python
     async def update_pair_filter(self, pair_id, key, value):
         pair = await self.get_pair(pair_id)
         filters = pair.filters or {}
         filters[key] = value
         await self.connection.execute(
             "UPDATE pairs SET filters = ? WHERE id = ?",
             (json.dumps(filters), pair_id)
         )
         await self.connection.commit()
     ```

2. **Admin Command** (`bot_manager.py`):
   - `/watermark <pair_id> <enable|disable> [text]`
   - Updates DB via `update_pair_filter`.
   - Sends confirmation to admin.

3. **Watermark Function** (`image_handler.py`):
   - Use Pillow to overlay text at center.
   - Font size = 5% of image width.
   - Semi-transparent white (RGBA: `(255,255,255,100)`).
   - Save output with same format as input.
   - Example:
     ```python
     def add_text_watermark(input_path, output_path, text):
         base = Image.open(input_path).convert("RGBA")
         txt_layer = Image.new("RGBA", base.size, (255,255,255,0))
         draw = ImageDraw.Draw(txt_layer)
         font_size = int(base.width * 0.05)
         font = ImageFont.truetype("arial.ttf", font_size)
         tw, th = draw.textsize(text, font=font)
         x, y = (base.width - tw) // 2, (base.height - th) // 2
         draw.text((x, y), text, font=font, fill=(255,255,255,100))
         watermarked = Image.alpha_composite(base, txt_layer)
         watermarked.convert("RGB").save(output_path, quality=95)
     ```

4. **Integration Point** (`message_processor.py` or `media_forwarder.py`):
   - After Telethon downloads media but before sending:
     ```python
     if message.photo or (message.document and message.document.mime_type.startswith("image/")):
         if pair.filters.get("watermark_enabled"):
             text = pair.filters.get("watermark_text", "")
             temp_in = await download_media(message)
             temp_out = temp_in.replace(".jpg", "_wm.jpg")
             try:
                 add_text_watermark(temp_in, temp_out, text)
                 send_media(temp_out)
             except Exception as e:
                 log.warning(f"Watermark failed: {e}")
                 send_media(temp_in)
     else:
         send_media(original_file)
     ```

5. **Error Safety**:
   - Wrap watermark logic in try/except to prevent crashes.
   - Skip watermark for unsupported formats (GIF, video, etc.).
   - Ensure temporary files are cleaned up after sending.

6. **Testing**:
   - Test with JPEG, PNG, and large/small images.
   - Confirm watermark is always visible but non-intrusive.
   - Verify no error rate increase in `health_monitor`.

Output:  
The final system should allow enabling/disabling watermark per pair, set custom text, apply centered watermark on supported images, and forward without increasing error rates.
